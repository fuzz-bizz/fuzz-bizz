# executor.py
#
# Safely executes LLM-generated Python code to produce seed bytes.
# Runs the code in a restricted environment with timeout protection.

import logging
import re
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import List, Callable

logger = logging.getLogger(__name__)


def extract_python_code(response: str) -> str:
    """Extract Python code from markdown code blocks in LLM response."""
    # Look for ```python ... ``` blocks
    pattern = r'```python\s*(.*?)\s*```'
    matches = re.findall(pattern, response, re.DOTALL)
    
    if matches:
        # Return the last (most complete) code block
        return matches[-1].strip()
    
    # Fallback: look for ``` ... ``` without language specifier
    pattern = r'```\s*(.*?)\s*```'
    matches = re.findall(pattern, response, re.DOTALL)
    
    if matches:
        # Find the one that looks like Python (has def gen_seed)
        for match in matches:
            if 'def gen_seed' in match:
                return match.strip()
    
    return ""


def extract_seed_functions(code: str) -> List[str]:
    """Extract individual seed function names from code."""
    pattern = r'def\s+(gen_seed\w*)\s*\('
    return re.findall(pattern, code)


def execute_seed_code(code: str, timeout: int = 10) -> List[bytes]:
    """
    Execute the generated Python code and collect seed bytes.
    
    Runs in a subprocess for safety and timeout protection.
    
    Args:
        code: Python code containing gen_seed_X() functions
        timeout: Maximum seconds to wait for execution
        
    Returns:
        List of seed bytes generated by the functions
    """
    seeds = []
    
    # Extract function names
    func_names = extract_seed_functions(code)
    if not func_names:
        logger.warning("No seed functions found in generated code")
        return seeds
    
    logger.info(f"Found {len(func_names)} seed functions: {func_names}")
    
    # Create a runner script that executes each function and saves output
    runner_code = code + "\n\n"
    runner_code += "import sys\n"
    runner_code += "import base64\n\n"
    runner_code += "if __name__ == '__main__':\n"
    runner_code += "    results = []\n"
    
    for func_name in func_names:
        runner_code += f"""
    try:
        result = {func_name}()
        if isinstance(result, bytes):
            print(f"SEED:{{base64.b64encode(result).decode()}}")
        else:
            print(f"SEED:{{base64.b64encode(str(result).encode()).decode()}}")
    except Exception as e:
        print(f"ERROR:{func_name}:{{e}}", file=sys.stderr)
"""
    
    # Write to temp file and execute
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(runner_code)
        temp_path = f.name
    
    try:
        result = subprocess.run(
            [sys.executable, temp_path],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        # Parse output
        for line in result.stdout.split('\n'):
            if line.startswith('SEED:'):
                try:
                    import base64
                    seed_b64 = line[5:].strip()
                    seed_bytes = base64.b64decode(seed_b64)
                    seeds.append(seed_bytes)
                    logger.debug(f"Got seed: {len(seed_bytes)} bytes")
                except Exception as e:
                    logger.warning(f"Failed to decode seed: {e}")
        
        # Log any errors
        if result.stderr:
            for line in result.stderr.split('\n'):
                if line.strip():
                    logger.warning(f"Seed execution: {line}")
                    
    except subprocess.TimeoutExpired:
        logger.error(f"Seed code execution timed out after {timeout}s")
    except Exception as e:
        logger.error(f"Failed to execute seed code: {e}")
    finally:
        # Clean up temp file
        try:
            Path(temp_path).unlink()
        except:
            pass
    
    logger.info(f"Successfully generated {len(seeds)} seeds")
    return seeds


def validate_seed_code(code: str) -> bool:
    """
    Basic validation of generated code for safety.
    
    Args:
        code: Python code to validate
        
    Returns:
        True if code appears safe to execute
    """
    # Check for dangerous patterns
    dangerous_patterns = [
        r'\bimport\s+os\b',
        r'\bimport\s+subprocess\b', 
        r'\bimport\s+sys\b.*\bsys\.exit\b',
        r'\b__import__\b',
        r'\beval\b',
        r'\bexec\b',
        r'\bopen\s*\(',
        r'\bfile\s*\(',
        r'\bcompile\b',
    ]
    
    for pattern in dangerous_patterns:
        if re.search(pattern, code):
            logger.warning(f"Potentially dangerous pattern in generated code: {pattern}")
            # Don't block, just warn - the subprocess isolation should protect us
    
    # Check that it has seed functions
    if not extract_seed_functions(code):
        logger.error("No gen_seed_X functions found in code")
        return False
    
    return True
